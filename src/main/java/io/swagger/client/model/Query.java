/*
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.threeten.bp.OffsetDateTime;
/**
 * For specifying result metrics.
 */
@Schema(description = "For specifying result metrics.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2023-02-22T14:44:19.166727222+09:00[Asia/Tokyo]")
public class Query {
  @SerializedName("dimensions")
  private List<String> dimensions = null;

  @SerializedName("filters")
  private String filters = "\"\"";

  @SerializedName("limit")
  private Integer limit = 10000;

  @SerializedName("metrics")
  private List<String> metrics = null;

  @SerializedName("since")
  private OffsetDateTime since = null;

  @SerializedName("sort")
  private List<Object> sort = null;

  @SerializedName("until")
  private OffsetDateTime until = null;

  public Query dimensions(List<String> dimensions) {
    this.dimensions = dimensions;
    return this;
  }

  public Query addDimensionsItem(String dimensionsItem) {
    if (this.dimensions == null) {
      this.dimensions = new ArrayList<String>();
    }
    this.dimensions.add(dimensionsItem);
    return this;
  }

   /**
   * Can be used to break down the data by given attributes.
   * @return dimensions
  **/
  @Schema(description = "Can be used to break down the data by given attributes.")
  public List<String> getDimensions() {
    return dimensions;
  }

  public void setDimensions(List<String> dimensions) {
    this.dimensions = dimensions;
  }

  public Query filters(String filters) {
    this.filters = filters;
    return this;
  }

   /**
   * Used to filter rows by one or more dimensions. Filters can be combined using OR and AND boolean logic. AND takes precedence over OR in all the expressions. The OR operator is defined using a comma (,) or OR keyword surrounded by whitespace. The AND operator is defined using a semicolon (;) or AND keyword surrounded by whitespace. Note that the semicolon is a reserved character in URLs (rfc1738) and needs to be percent-encoded as %3B. Comparison options are:   Operator                  | Name                            | URL Encoded --------------------------|---------------------------------|-------------------------- &#x3D;&#x3D;                        | Equals                          | %3D%3D !&#x3D;                        | Does not equals                 | !%3D &gt;                        | Greater Than                    | %3E &lt;                         | Less Than                       | %3C &gt;&#x3D;                       | Greater than or equal to        | %3E%3D &lt;&#x3D;                        | Less than or equal to           | %3C%3D     .
   * @return filters
  **/
  @Schema(description = "Used to filter rows by one or more dimensions. Filters can be combined using OR and AND boolean logic. AND takes precedence over OR in all the expressions. The OR operator is defined using a comma (,) or OR keyword surrounded by whitespace. The AND operator is defined using a semicolon (;) or AND keyword surrounded by whitespace. Note that the semicolon is a reserved character in URLs (rfc1738) and needs to be percent-encoded as %3B. Comparison options are:   Operator                  | Name                            | URL Encoded --------------------------|---------------------------------|-------------------------- ==                        | Equals                          | %3D%3D !=                        | Does not equals                 | !%3D >                        | Greater Than                    | %3E <                         | Less Than                       | %3C >=                       | Greater than or equal to        | %3E%3D <=                        | Less than or equal to           | %3C%3D     .")
  public String getFilters() {
    return filters;
  }

  public void setFilters(String filters) {
    this.filters = filters;
  }

  public Query limit(Integer limit) {
    this.limit = limit;
    return this;
  }

   /**
   * Limit number of returned metrics.
   * @return limit
  **/
  @Schema(description = "Limit number of returned metrics.")
  public Integer getLimit() {
    return limit;
  }

  public void setLimit(Integer limit) {
    this.limit = limit;
  }

  public Query metrics(List<String> metrics) {
    this.metrics = metrics;
    return this;
  }

  public Query addMetricsItem(String metricsItem) {
    if (this.metrics == null) {
      this.metrics = new ArrayList<String>();
    }
    this.metrics.add(metricsItem);
    return this;
  }

   /**
   * One or more metrics to compute.
   * @return metrics
  **/
  @Schema(description = "One or more metrics to compute.")
  public List<String> getMetrics() {
    return metrics;
  }

  public void setMetrics(List<String> metrics) {
    this.metrics = metrics;
  }

  public Query since(OffsetDateTime since) {
    this.since = since;
    return this;
  }

   /**
   * Start of time interval to query, defaults to 6 hours before request received.
   * @return since
  **/
  @Schema(example = "2019-01-02T02:20Z", description = "Start of time interval to query, defaults to 6 hours before request received.")
  public OffsetDateTime getSince() {
    return since;
  }

  public void setSince(OffsetDateTime since) {
    this.since = since;
  }

  public Query sort(List<Object> sort) {
    this.sort = sort;
    return this;
  }

  public Query addSortItem(Object sortItem) {
    if (this.sort == null) {
      this.sort = new ArrayList<Object>();
    }
    this.sort.add(sortItem);
    return this;
  }

   /**
   * Array of dimensions or metrics to sort by, each dimension/metric may be prefixed by - (descending) or + (ascending).
   * @return sort
  **/
  @Schema(description = "Array of dimensions or metrics to sort by, each dimension/metric may be prefixed by - (descending) or + (ascending).")
  public List<Object> getSort() {
    return sort;
  }

  public void setSort(List<Object> sort) {
    this.sort = sort;
  }

  public Query until(OffsetDateTime until) {
    this.until = until;
    return this;
  }

   /**
   * End of time interval to query, defaults to current time.
   * @return until
  **/
  @Schema(example = "2019-01-02T03:20Z", description = "End of time interval to query, defaults to current time.")
  public OffsetDateTime getUntil() {
    return until;
  }

  public void setUntil(OffsetDateTime until) {
    this.until = until;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Query query = (Query) o;
    return Objects.equals(this.dimensions, query.dimensions) &&
        Objects.equals(this.filters, query.filters) &&
        Objects.equals(this.limit, query.limit) &&
        Objects.equals(this.metrics, query.metrics) &&
        Objects.equals(this.since, query.since) &&
        Objects.equals(this.sort, query.sort) &&
        Objects.equals(this.until, query.until);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dimensions, filters, limit, metrics, since, sort, until);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Query {\n");
    
    sb.append("    dimensions: ").append(toIndentedString(dimensions)).append("\n");
    sb.append("    filters: ").append(toIndentedString(filters)).append("\n");
    sb.append("    limit: ").append(toIndentedString(limit)).append("\n");
    sb.append("    metrics: ").append(toIndentedString(metrics)).append("\n");
    sb.append("    since: ").append(toIndentedString(since)).append("\n");
    sb.append("    sort: ").append(toIndentedString(sort)).append("\n");
    sb.append("    until: ").append(toIndentedString(until)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
